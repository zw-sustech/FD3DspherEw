"""
fdpytool: The sub-function python spool to gather, locate and retrieve seismo/media/snapshot generated by FD3DTopoEw package.

Author:
  Yuanhang Huo  (yhhuo@mail.ustc.edu.cn)
  Wei Zhang     (zhangwei@sustech.edu.cn)
Affiliation:
  University of Science and Technology of China
  Southern University of Science and Technology
Date:
  2019-09-03

"""

import numpy as np
import os
from netCDF4 import Dataset

#--------------- gather_coord ---------------#
def gather_coord(snapinfo,coordvar,coordvarpath):
    #print(snapinfo)
    """
    gather_coord: Gather and output the grid coordinates in the snap box or snap slice.
    Input:
        snapinfo: snap information from the subfunction 'locate_snap' output
        coordvar: flag string, set 'coorddir'
        coordvarpath: path of the coordinates' nc files
    Output:
        X, Y and Z coordinates according to the snap
    Usage:
        X,Y,Z = gather_coord(snapinfo,'coorddir','./input')
    """

    pnm_nc=coordvarpath
    if os.path.exists(pnm_nc):
        nthd=len(snapinfo)
        for n in range(nthd):
            n_i=snapinfo[n]['thisid'][0]
            n_j=snapinfo[n]['thisid'][1]
            n_k=snapinfo[n]['thisid'][2]
            #print(n_i,n_j,n_k)
            i1=snapinfo[n]['indxs'][0]
            j1=snapinfo[n]['indxs'][1]
            k1=snapinfo[n]['indxs'][2]
            #print(i1,j1,k1)
            i2=snapinfo[n]['indxe'][0]
            j2=snapinfo[n]['indxe'][1]
            k2=snapinfo[n]['indxe'][2]
            #print(i2,j2,k2)
            subs=snapinfo[n]['wsubs']
            subc=snapinfo[n]['wsubc']
            subt=snapinfo[n]['wsubt']
            #print(subs,subc,subt)
            fnm_coord=get_fnm_coord(pnm_nc,n_i,n_j,n_k)

            if os.path.exists(fnm_coord):
                subs=subs[::-1]
                subc=subc[::-1]
                subt=subt[::-1]

                coordnc=Dataset(fnm_coord)
                
#                xblk=np.array(coordnc.variables['x'][subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
#                         subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
#                        subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
#                        dtype=np.float64)
                xblk=np.array(coordnc.variables['x'][subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
                         dtype=np.float64)
                #print('xblk',len(xblk))
#                yblk=np.array(coordnc.variables['y'][subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
#                        subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
#                        subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
#                        dtype=np.float64)
                yblk=np.array(coordnc.variables['y'][subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1]],\
                        dtype=np.float64)
                #print('yblk',len(yblk))
#                zblk=np.array(coordnc.variables['z'][subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
#                        subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
#                        subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
#                        dtype=np.float64)
                zblk=np.array(coordnc.variables['z'][subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0]],\
                        dtype=np.float64)
                #print('zblk',len(zblk))
                if n ==0:
                    xold=xblk
                    yold=yblk
                    zold=zblk
                
                xnew=np.empty((max(i2,xold.shape[0])))               
                ynew=np.empty((max(j2,yold.shape[0])))
                znew=np.empty((max(k2,zold.shape[0])))
                print(len(xnew),len(ynew),len(znew))
#                xnew=np.empty((max(k2,xold.shape[0]),max(j2,xold.shape[1]),max(i2,xold.shape[2])))
#                ynew=np.empty((max(k2,xold.shape[0]),max(j2,xold.shape[1]),max(i2,xold.shape[2])))
#                znew=np.empty((max(k2,xold.shape[0]),max(j2,xold.shape[1]),max(i2,xold.shape[2])))
                
#                xnew[:xold.shape[0],:xold.shape[1],:xold.shape[2]]=xold
#                ynew[:yold.shape[0],:yold.shape[1],:yold.shape[2]]=yold
#                znew[:zold.shape[0],:zold.shape[1],:zold.shape[2]]=zold
                xnew[:xold.shape[0]]=xold
                ynew[:yold.shape[0]]=yold
                znew[:zold.shape[0]]=zold

#                xnew[k1-1:k2,j1-1:j2,i1-1:i2]=xblk
#                ynew[k1-1:k2,j1-1:j2,i1-1:i2]=yblk
#                znew[k1-1:k2,j1-1:j2,i1-1:i2]=zblk
                xnew[i1-1:i2]=xblk
                ynew[j1-1:j2]=yblk
                znew[k1-1:k2]=zblk

                xold=xnew
                yold=ynew
                zold=znew

            else:
                print("Error in 'gather_coord': File " + "'" + fnm_coord + "'" + \
                        " does NOT exist.")

#        xnew=xnew.transpose(2,1,0)
#        ynew=ynew.transpose(2,1,0)
#        znew=znew.transpose(2,1,0)
           
        return(xnew,ynew,znew)

    else:
        print("Error in 'gather_coord': Directory " + "'" + pnm_nc + "'" + \
                " does NOT exist.")



#--------------- gather_dist ---------------#
def gather_dist(snapinfo,snapid,varnm,outvar,outvarpath):

    listV=['Vx','Vy','Vz','Vn','Ve','Vh','Va']
    listA=['Ax','Ay','Az','An','Ae','Ah','Aa']
    listD=['Dx','Dy','Dz','Dn','De','Dh','Da']
    listK=['Kapx','Kaqx','Kbpx','Kbqx',\
           'Kapy','Kaqy','Kbpy','Kbqy',\
           'Kapz','Kaqz','Kbpz','Kbqz']
    listk=['kernel_phase_Vp','kernel_amplitude_Vp',\
           'kernel_phase_Vs','kernel_amplitude_Vs']
    listp=['phase_Vp','amplitude_Vp','phase_Vs','amplitude_Vs']
    if varnm in listV:
        fnm_prefix='Vmax_'
    elif varnm in listA:
        fnm_prefix='Amax_'
    elif varnm in listD:
        fnm_prefix='Dmax_'
    elif varnm in listK:
        fnm_prefix='kernel_V' + varnm + '_'
    else:
        fnm_prefix='kernel_'

    pnm_out=outvarpath
    nofnc=0
    if os.path.exists(pnm_out):
        nthd=len(snapinfo)
        for n in range(nthd):
            n_i=snapinfo[n]['thisid'][0]
            n_j=snapinfo[n]['thisid'][1]
            n_k=snapinfo[n]['thisid'][2]
            
            i1=snapinfo[n]['indxs'][0]
            j1=snapinfo[n]['indxs'][1]
            k1=snapinfo[n]['indxs'][2]

            i2=snapinfo[n]['indxe'][0]
            j2=snapinfo[n]['indxe'][1]
            k2=snapinfo[n]['indxe'][2]

            subs=snapinfo[n]['wsubs']
            subc=snapinfo[n]['wsubc']
            subt=snapinfo[n]['wsubt']

            fnm_snap=get_fnm_snap(pnm_out,fnm_prefix,n_i,n_j,n_k,snapid,nofnc)

            if os.path.exists(fnm_snap):
                subs=subs[::-1]
                subc=subc[::-1]
                subt=subt[::-1]

                snapnc=Dataset(fnm_snap)
                vblk=np.array(snapnc.variables[varnm][subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
                        subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
                        subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
                        dtype=np.float64)

                if n ==0:
                    vold=vblk

                vnew=np.empty((max(k2,vold.shape[0]),max(j2,vold.shape[1]),max(i2,vold.shape[2])))

                vnew[:vold.shape[0],:vold.shape[1],:vold.shape[2]]=vold

                vnew[k1-1:k2,j1-1:j2,i1-1:i2]=vblk

                vold=vnew

            else:
                print("Error in 'gather_list': File " + "'" + fnm_snap + "'" + \
                        " does NOT exist.")
        
        vnew=vnew.transpose(2,1,0)
        print(vnew.shape)
            
        return(vnew)

    else:
        print("Error in 'gather_list': Directory " + "'" + pnm_out + "'" + \
                " does NOT exist.")



#--------------- gather_media ---------------#
def gather_media(snapinfo,varnm,mediavar,mediavarpath):

    """
    gather_media: Gather and output the media parameters in the snap box or snap slice.
    Input:
        snapinfo: snap information from the subfunction 'locate_snap' output
        varnm: variable name to output, set 'rho', 'mu' or 'lambda'
        mediavar: flag string, set 'mediadir'
        mediavarpath: path of the media nc files
    Output:
        Media parameters ('rho','mu' or 'lambda') according to the snap
    Usage:
        rho = gather_media(snapinfo,'rho','mediadir','./input')
        mu  = gather_media(snapinfo,'mu','mediadir','./input')
        lambda = gather_media(snapinfo,'lambda','mediadir','./input')
    """

    pnm_nc=mediavarpath
    if os.path.exists(pnm_nc):
        nthd=len(snapinfo)
        for n in range(nthd):
            n_i=snapinfo[n]['thisid'][0]
            n_j=snapinfo[n]['thisid'][1]
            n_k=snapinfo[n]['thisid'][2]
            
            i1=snapinfo[n]['indxs'][0]
            j1=snapinfo[n]['indxs'][1]
            k1=snapinfo[n]['indxs'][2]

            i2=snapinfo[n]['indxe'][0]
            j2=snapinfo[n]['indxe'][1]
            k2=snapinfo[n]['indxe'][2]

            subs=snapinfo[n]['wsubs']
            subc=snapinfo[n]['wsubc']
            subt=snapinfo[n]['wsubt']

            fnm_media=get_fnm_media(pnm_nc,n_i,n_j,n_k)

            if os.path.exists(fnm_media):
                subs=subs[::-1]
                subc=subc[::-1]
                subt=subt[::-1]

                medianc=Dataset(fnm_media)
                vblk=np.array(medianc.variables[varnm][subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
                        subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
                        subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
                        dtype=np.float64)

                if n ==0:
                    vold=vblk

                vnew=np.empty((max(k2,vold.shape[0]),max(j2,vold.shape[1]),max(i2,vold.shape[2])))

                vnew[:vold.shape[0],:vold.shape[1],:vold.shape[2]]=vold

                vnew[k1-1:k2,j1-1:j2,i1-1:i2]=vblk

                vold=vnew

            else:
                print("Error in 'gather_media': File " + "'" + fnm_media + "'" + \
                        " does NOT exist.")
        
        vnew=vnew.transpose(2,1,0)
            
        return(vnew)

    else:
        print("Error in 'gather_media': Directory " + "'" + pnm_nc + "'" + \
                " does NOT exist.")



#--------------- gather_metric ---------------#
def gather_metric(snapinfo,varnm,metricvar,metricvarpath):

    """
    gather_metric: Gather and output the metric parameters in the snap box or snap slice.
    Input:
        snapinfo: snap information from the subfunction 'locate_snap' output
        varnm: variable name to output, set 'xi_x','xi_y','xi_z','eta_x','eta_y','eta_z','zeta_x','zeta_y','zeta_z','jac'
        metricvar: flag string, set 'metricdir'
        metricvarpath: path of the metric nc files
    Output:
        Metric parameters ('xi_x','eta_z','zeta_x','jac', etc.) according to the snap
    Usage:
        xi_x   = gather_metric(snapinfo,'xi_x','metricdir','./input')
        eta_x  = gather_metric(snapinfo,'eta_x','metricdir','./input')
        zeta_x = gather_metric(snapinfo,'zeta_x','metricdir','./input')
        jac    = gather_metric(snapinfo,'jac_x','metricdir','./input')
    """

    pnm_nc=metricvarpath
    if os.path.exists(pnm_nc):
        nthd=len(snapinfo)
        for n in range(nthd):
            n_i=snapinfo[n]['thisid'][0]
            n_j=snapinfo[n]['thisid'][1]
            n_k=snapinfo[n]['thisid'][2]
            
            i1=snapinfo[n]['indxs'][0]
            j1=snapinfo[n]['indxs'][1]
            k1=snapinfo[n]['indxs'][2]

            i2=snapinfo[n]['indxe'][0]
            j2=snapinfo[n]['indxe'][1]
            k2=snapinfo[n]['indxe'][2]

            subs=snapinfo[n]['wsubs']
            subc=snapinfo[n]['wsubc']
            subt=snapinfo[n]['wsubt']

            fnm_metric=get_fnm_metric(pnm_nc,n_i,n_j,n_k)

            if os.path.exists(fnm_metric):
                subs=subs[::-1]
                subc=subc[::-1]
                subt=subt[::-1]

                metricnc=Dataset(fnm_metric)
                vblk=np.array(metricnc.variables[varnm][subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
                        subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
                        subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
                        dtype=np.float64)

                if n ==0:
                    vold=vblk

                vnew=np.empty((max(k2,vold.shape[0]),max(j2,vold.shape[1]),max(i2,vold.shape[2])))

                vnew[:vold.shape[0],:vold.shape[1],:vold.shape[2]]=vold

                vnew[k1-1:k2,j1-1:j2,i1-1:i2]=vblk

                vold=vnew

            else:
                print("Error in 'gather_metric': File " + "'" + fnm_metric + "'" + \
                        " does NOT exist.")
        
        vnew=vnew.transpose(2,1,0)
        print(vnew.shape)
            
        return(vnew)

    else:
        print("Error in 'gather_metric': Directory " + "'" + pnm_nc + "'" + \
                " does NOT exist.")



#--------------- gather_snap ---------------#
def gather_snap(snapinfo,snapid,nlayer,varnm,outvar,outvarpath):

    """
    gather_snap: Gather and output the simulation results (velocity, displacement, acceleration or stress) from FD3DTopoEw
    Input:
        snapinfo: snap information from the subfunction 'locate_snap' output
        snapid: snap index, see 'SeisFD3D.conf'
        nlayer: time index to view and plot
        varnm:  variable name we want to obtain, set 'Vx','Vy','Vz','Txx','Txy','Txz','Tyy','Tyz','Tzz'
        outvar: flag string, set 'outdir'
        outvarpath: path of the output nc files
    Output:
        Velocity/displacement/acceleration/stress and the instant time
    Usage:
        vel,t = gather_snap(snapinfo,1,100,'Vz','outdir','./output')
        sgt,t = gather_snap(snapinfo,3,200,'Tyy','outdir','./output')
    """

    listV=['Vx','Vy','Vz']
    listA=['Ax','Ay','Az']
    listD=['Dx','Dy','Dz']
    listT=['Txx','Txy','Txz','Tyy','Tyz','Tzz']
    if varnm in listV:
        fnm_prefix='vel_'
    elif varnm in listA:
        fnm_prefix='acce_'
    elif varnm in listD:
        fnm_prefix='disp_'
    else:
        fnm_prefix='sgt_'

    pnm_out=outvarpath

    if os.path.exists(pnm_out):

        nthd=len(snapinfo)
        nofnc=int(np.floor((nlayer-1)/snapinfo[0]['tcnt'])+1)
        ninnc=(nlayer-1) % snapinfo[0]['tcnt']

        for n in range(nthd):
            n_i=snapinfo[n]['thisid'][0]
            n_j=snapinfo[n]['thisid'][1]
            n_k=snapinfo[n]['thisid'][2]
            
            i1=snapinfo[n]['indxs'][0]
            j1=snapinfo[n]['indxs'][1]
            k1=snapinfo[n]['indxs'][2]

            i2=snapinfo[n]['indxe'][0]
            j2=snapinfo[n]['indxe'][1]
            k2=snapinfo[n]['indxe'][2]

            subs=snapinfo[n]['subs']
            subc=snapinfo[n]['subc']
            subt=snapinfo[n]['subt']

            fnm_snap=get_fnm_snap(pnm_out,fnm_prefix,n_i,n_j,n_k,snapid,nofnc)

            if os.path.exists(fnm_snap):
                snapnc=Dataset(fnm_snap)
                tdim={}
                tdim['Name']=snapnc.dimensions['time'].name
                tdim['Length']=snapnc.dimensions['time'].size
                
                if tdim['Length'] == 0 or ninnc-1 >= tdim['Length']:
                    print("Error in 'gather_snap': " + str(ninnc+1) + \
                            "th layer is beyond current time dim" + "(" + \
                            str(tdim['Length']) + ") in " + fnm_snap)
                else:
                    subs=subs[::-1]
                    subc=subc[::-1]
                    subt=subt[::-1]

                    vblk=np.array(snapnc.variables[varnm][ninnc,\
                            subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
                            subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
                            subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
                            dtype=np.float64)

                    if n == 0:
                        vold=vblk
                        t=snapnc.variables['time'][ninnc]

                    vnew=np.empty((max(k2,vold.shape[0]),max(j2,vold.shape[1]),max(i2,vold.shape[2])))
    
                    vnew[:vold.shape[0],:vold.shape[1],:vold.shape[2]]=vold
    
                    vnew[k1-1:k2,j1-1:j2,i1-1:i2]=vblk
    
                    vold=vnew

            else:
                print("Error in 'gather_snap': File " + "'" + fnm_snap + "'" + \
                        " does NOT exist.")
        
        vnew=vnew.transpose(2,1,0)
            
        return(vnew,t)

    else:
        print("Error in 'gather_snap': Directory " + "'" + pnm_out + "'" + \
                " does NOT exist.")



#--------------- get_fnm_coord ---------------#
def get_fnm_coord(pnm,n_i,n_j,n_k):

    """
    get_fnm_coord: Output the coordinate filename
    Input:
        pnm: path of the coordinate nc file
        n_i: i index
        n_j: j index
        n_k: k index
    Output:
        The full filename of coordinate nc
    Usage:
        fnm_coord = get_fnm_coord('./input',2,3,4)
    """

    fnm_out=pnm + '/' + 'coord_mpi' + \
            "{:0>2d}".format(n_i) + \
            "{:0>2d}".format(n_j) + \
            "{:0>2d}".format(n_k) + \
            '.nc'
    return(fnm_out)



#--------------- get_fnm_media ---------------#
def get_fnm_media(pnm,n_i,n_j,n_k):

    """
    get_fnm_media: Output the media filename
    Input:
        pnm: path of the media nc file
        n_i: i index
        n_j: j index
        n_k: k index
    Output:
        The full filename of media nc
    Usage:
        fnm_media = get_fnm_media('./input',2,3,4)
    """
    
    fnm_out=pnm + '/' + 'media_mpi' + \
            "{:0>2d}".format(n_i) + \
            "{:0>2d}".format(n_j) + \
            "{:0>2d}".format(n_k) + \
            '.nc'
    return(fnm_out)



#--------------- get_fnm_metric ---------------#
def get_fnm_metric(pnm,n_i,n_j,n_k):

    """
    get_fnm_metric: Output the metric filename
    Input:
        pnm: path of the metirc nc file
        n_i: i index
        n_j: j index
        n_k: k index
    Output:
        The full filename of metric nc
    Usage:
        fnm_metric = get_fnm_metric('./input',2,3,4)
    """

    fnm_out=pnm + '/' + 'metric_mpi' + \
            "{:0>2d}".format(n_i) + \
            "{:0>2d}".format(n_j) + \
            "{:0>2d}".format(n_k) + \
            '.nc'
    return(fnm_out)



#--------------- get_fnm_seismo ---------------#
def get_fnm_seismo(pnm,n_i,n_j,n_k):

    """
    get_fnm_seismo: Output the seismo filename
    Input:
        pnm: path of the seismo nc file
        n_i: i index
        n_j: j index
        n_k: k index
    Output:
        The full filename of seismo nc
    Usage:
        fnm_seismo = get_fnm_seismo('./output',2,3,4)
    """

    fnm_out=pnm + '/' + 'seismo_mpi' + \
            "{:0>2d}".format(n_i) + \
            "{:0>2d}".format(n_j) + \
            "{:0>2d}".format(n_k) + \
            '.nc'
    return(fnm_out)



#--------------- get_fnm_snap ---------------#
def get_fnm_snap(pnm,prefix,n_i,n_j,n_k,id,n):

    """
    get_fnm_snap: Output the snap filename
    Input:
        pnm: path of the snap nc file
        prefix: prefix of file name, 'vel_' for velocity, 'sgt_' for stress
        n_i: i index
        n_j: j index
        n_k: k index
        id: index of snapshot
        n: number of sub-snapshor for one snapshot divided by 'n' sub-snapshot, '1' for common case
    Output:
        The full filename of snap nc
    Usage:
        fnm_snap = get_fnm_snap('./output','vel_',2,3,4,1,1)
    """

    fnm_out=pnm + '/' + prefix + \
            "{:0>3d}".format(id) + '_mpi' + \
            "{:0>2d}".format(n_i) + \
            "{:0>2d}".format(n_j) + \
            "{:0>2d}".format(n_k) + \
            '_n' + "{:0>5d}".format(n) + \
            '.nc'
    return(fnm_out)



#--------------- get_fnm_station ---------------#
def get_fnm_station(pnm,n_i,n_j,n_k):

    """
    get_fnm_station: Output the station filename
    Input:
        pnm: path of the station nc file
        n_i: i index
        n_j: j index
        n_k: k index
    Output:
        The full filename of station nc
    Usage:
        fnm_station = get_fnm_station('./input',2,3,4)
    """

    fnm_out=pnm + '/' + 'station_mpi' + \
            "{:0>2d}".format(n_i) + \
            "{:0>2d}".format(n_j) + \
            "{:0>2d}".format(n_k) + \
            '.nc'
    return(fnm_out)



#--------------- get_fnm_path ---------------#
def get_sim_path(RUN_ROOT='.'):

    """
    get_sim_path: Get the filename or pathname of conf, coord, media, etc.
    Input:
        RUN_ROOT: appropriate parent path
    Output:
        Pathnames and filenames
    Usage:
        conf,coord,metric,media,source,station,out = get_sim_path('/home/yhhuo/fd3d/example')
    """
        
    fnm_conf   = RUN_ROOT + '/' + 'SeisFD3D.conf'
    dir_coord  = RUN_ROOT + '/' + 'input'
    dir_metric = RUN_ROOT + '/' + 'input'
    dir_media  = RUN_ROOT + '/' + 'input'
    dir_source = RUN_ROOT + '/' + 'input'
    dir_station= RUN_ROOT + '/' + 'input'
    dir_out    = RUN_ROOT + '/' + 'output'

    return fnm_conf,dir_coord,dir_metric,dir_media,dir_source,dir_station,dir_out



#--------------- locate_seismo ---------------#
def locate_seismo(filename,id,indx,pnm_info):
    
    """
    locate_seismo: Locate the index of seismo.
    Input:
        filename: full filename of 'SeisFD3D.conf' including the path
        id: set '0' for specific receivers, set '1' for receiver line
        indx: receiver index
        pnm_info: path of the station nc files
    Output:
        The seismo information according to the receivers we want to locate
    Usage:
        seismoinfo = locate_seismo('./SeisFD3D.conf',0,1,'./input')
    """
    
    if os.path.exists(filename):
        f=open(filename,'r')
        for line in f:
            line=line.replace('=',' ').strip()
            if line:
                tag=line.split()[0]
                if tag == 'dims':
                    dims=line.split()[1:4]
                if tag == 'ni':
                    ni=line.split()[1]
                if tag == 'nj':
                    nj=line.split()[1]
                if tag == 'nk':
                    nk=line.split()[1]
                if tag == 'nt':
                    nt=line.split()[1]
                if tag == 'GRID_ROOT':
                    pnm_grid=line.split()[1]
                if tag == 'MEDIA_ROOT':
                    pnm_media=line.split()[1]
                if tag == 'SOURCE_ROOT':
                    pnm_src=line.split()[1]
                if tag == 'OUTPUT_ROOT':
                    pnm_output=line.split()[1]
                if tag == 'number_of_recv':
                    num_recv=line.split()[1]
                if tag == 'number_of_inline':
                    num_line=line.split()[1]
                if tag == 'number_of_snap':
                    num_snap=line.split()[1]

        seismoinfo={}
        for n_k in np.arange(0,int(dims[2])):
            for n_j in np.arange(0,int(dims[1])):
                for n_i in np.arange(0,int(dims[0])):
                    fnm_nc=get_fnm_station(pnm_info,n_i,n_j,n_k)
                    stanc=Dataset(fnm_nc)
                    recvid=np.array(stanc.variables['id'][:])

                    if recvid.size == 0:
                        npt=-1
                    elif recvid.size == 2:
                        if recvid[0,0] == indx:
                            npt=0
                    else:
                        npt=np.intersect1d(np.argwhere(recvid[:,0]==indx),np.argwhere(recvid[:,1]==id))

                    if 'npt' in locals() and npt >= 0:
                        seismoinfo['n_i']=n_i
                        seismoinfo['n_j']=n_j
                        seismoinfo['n_k']=n_k
                        seismoinfo['npt']=npt
                        return(seismoinfo)

        if not seismoinfo:
            print("Error in 'locate_seismo': This receiver does NOT exist: " + \
                    "index = " + str(indx) + " , " + "id = " + str(id))

    else:
        print("Error in 'locate_seismo': " + "'" + filename + "'" + " does NOT exist. Please check it.")



#--------------- locate_snap ---------------#
def locate_snap(fnm_conf,id,startvar,gsubs,countvar,gsubc,stridevar,gsubt):
    
    """
    locate_snap: Locate the index of snap.
    Input:
        fnm_conf: full filename of 'SeisFD3D.conf' including the path
        id: index of snap we want to locate, see 'SeisFD3D.conf'
        startvar: flag string, set 'start'
        gsubs: starting grid index
        countvar: flag string, set 'count'
        gsubc: counts of grid index
        stridevar: flag string, set 'stride'
        gsubt: stride for grid index
    Output:
        The snap information according to the snaps we want to locate
    Usage:
        snapinfo = locate_snap('./SeisFD3D.conf',1,'start',[1,1,1],'count',[10,10,10],'stride','[1,1,1]')
        snapinfo = locate_snap('./SeisFD3D.conf',1,'start',[2,2,2,1],'count',[-1,-1,-1,-1],'stride',[3,3,3,3])
    """

    gtstart=1
    gtcount=-1
    gtstride=1

    LenFD=3

    if len(gsubs) == 4:
        gtstart=gsubs[3]
        gsubs=gsubs[0:3]
    if len(gsubc) == 4:
        gtcount=gsubc[3]
        gsubc=gsubc[0:3]
    if len(gsubt) == 4:
        gtstride=gsubt[3]
        gsubt=gsubt[0:3]

    gsubs=np.array(gsubs)
    gsubc=np.array(gsubc)
    gsubt=np.array(gsubt)

    if os.path.exists(fnm_conf):
        f=open(fnm_conf,'r')
        stag='snap_' + "{:0>3d}".format(id)
        print(stag)
        for line in f:
            line=line.replace('=',' ').strip()
            if line:
                tag=line.split()[0]
                if tag == 'dims':
                    dims=line.split()[1:4]
                if tag == 'ni':
                    ni=int(line.split()[1])
                if tag == 'nj':
                    nj=int(line.split()[1])
                if tag == 'nk':
                    nk=int(line.split()[1])
                if tag == 'nt':
                    nt=line.split()[1]
                if tag == 'GRID_ROOT':
                    pnm_grid=line.split()[1]
                if tag == 'MEDIA_ROOT':
                    pnm_media=line.split()[1]
                if tag == 'SOURCE_ROOT':
                    pnm_src=line.split()[1]
                if tag == 'OUTPUT_ROOT':
                    pnm_output=line.split()[1]
                if tag == 'number_of_recv':
                    num_recv=line.split()[1]
                if tag == 'number_of_inline':
                    num_line=line.split()[1]
                if tag == 'number_of_snap':
                    num_snap=line.split()[1]
                if tag == stag:
                    lstr=line.split()[1:13]
                    snap_subs=np.array([int(lstr[0]),int(lstr[1]),int(lstr[2])])
                    snap_subc=np.array([int(lstr[3]),int(lstr[4]),int(lstr[5])])
                    snap_subt=np.array([int(lstr[6]),int(lstr[7]),int(lstr[8])])
                    snap_tinv=int(lstr[9])
                    snap_tcnt=int(lstr[10])
                    snap_stress=0
                    if lstr[11]:
                        if lstr[11].lower() == 't':
                            snap_stress=1


        ngi=ni*int(dims[0])
        ngj=nj*int(dims[1])
        ngk=nk*int(dims[2])
        ngijk=np.array([ngi,ngj,ngk])

        if id == 0:
            snap_subs=np.array([ 1, 1, 1])
            snap_subc=np.array([-1,-1,-1])
            snap_subt=np.array([ 1, 1, 1])
            snap_tinv=1
            snap_tcnt=1

        if 'snap_subs' in locals():
            indx=np.argwhere(snap_subc==-1).flatten()
            snap_subc[indx]=np.array(np.floor((ngijk[indx]-snap_subs[indx])/snap_subt[indx])+1,dtype=np.int64)
            snap_sube=snap_subs+(snap_subc-1)*snap_subt

            indx=np.argwhere(gsubc==-1).flatten()
            gsubc[indx]=np.array(np.floor((snap_subc[indx]-gsubs[indx])/gsubt[indx])+1,dtype=np.int64)
            gsube=gsubs+(gsubc-1)*gsubt

            ilist=np.arange(snap_subs[0],snap_sube[0]+snap_subt[0],snap_subt[0])
            jlist=np.arange(snap_subs[1],snap_sube[1]+snap_subt[1],snap_subt[1])
            klist=np.arange(snap_subs[2],snap_sube[2]+snap_subt[2],snap_subt[2])

            rlist=np.arange(gsubs[0],gsube[0]+gsubt[0],gsubt[0])
            slist=np.arange(gsubs[1],gsube[1]+gsubt[1],gsubt[1])
            tlist=np.arange(gsubs[2],gsube[2]+gsubt[2],gsubt[2])

            ulist=ilist[rlist-1]
            vlist=jlist[slist-1]
            wlist=klist[tlist-1]


            n_i1=int((ulist[0] -1)/ni)
            n_i2=int((ulist[-1]-1)/ni)
            n_j1=int((vlist[0] -1)/nj)
            n_j2=int((vlist[-1]-1)/nj)
            n_k1=int((wlist[0] -1)/nk)
            n_k2=int((wlist[-1]-1)/nk)

            # Locate
            snapinfo=[]
            for n_i in range(n_i1,n_i2+1):
                for n_j in range(n_j1,n_j2+1):
                    for n_k in range(n_k1,n_k2+1):
                        subinfo={}
                        subinfo['thisid']=np.array([n_i,n_j,n_k])
                        i=np.intersect1d(np.argwhere(ulist>=ni*n_i+1),np.argwhere(ulist<=ni*(n_i+1)))+1
                        j=np.intersect1d(np.argwhere(vlist>=nj*n_j+1),np.argwhere(vlist<=nj*(n_j+1)))+1
                        k=np.intersect1d(np.argwhere(wlist>=nk*n_k+1),np.argwhere(wlist<=nk*(n_k+1)))+1
                        subinfo['indxs']=np.array([i[0],j[0],k[0]])
                        subinfo['indxe']=np.array([i[-1],j[-1],k[-1]])
                        subinfo['indxc']=subinfo['indxe']-subinfo['indxs']+1

                        subinfo['wsubs']=np.array([ulist[i[0]-1]-ni*n_i,vlist[j[0]-1]-nj*n_j,wlist[k[0]-1]-nk*n_k])+LenFD
                        subinfo['wsubc']=subinfo['indxc']
                        subinfo['wsubt']=snap_subt*gsubt

                        r=np.intersect1d(np.argwhere(ilist>=ni*n_i+1),np.argwhere(ilist<=ni*(n_i+1)))+1
                        s=np.intersect1d(np.argwhere(jlist>=nj*n_j+1),np.argwhere(jlist<=nj*(n_j+1)))+1
                        t=np.intersect1d(np.argwhere(klist>=nk*n_k+1),np.argwhere(klist<=nk*(n_k+1)))+1
                        subinfo['subs']=np.array([(ulist[i[0]-1]-ilist[r[0]-1])/snap_subt[0]+1,\
                                (vlist[j[0]-1]-jlist[s[0]-1])/snap_subt[1]+1,\
                                (wlist[k[0]-1]-klist[t[0]-1])/snap_subt[2]+1],dtype=np.int64)
                        subinfo['subc']=subinfo['indxc']
                        subinfo['subt']=gsubt

                        subinfo['tinv']=snap_tinv
                        subinfo['tcnt']=snap_tcnt

                        subinfo['ttriple']=np.array([gtstart,gtcount,gtstride])
                        
                        snapinfo.append(subinfo)

            return(snapinfo)

        else:
            print("Error in 'locate_snap': " + "id = " + str(id) + " does NOT exist.")

    else:
        print("Error in 'locate_snap': " + "'" + fnm_conf + "'" + " does NOT exist. Please check it.")



#--------------- retrieve_seismo ---------------#
def retrieve_seismo(seismoinfo,varnm,outvar,outvarpath):

    """
    retrieve_seismo: Retrieve the velocity and stress component from output of forward modeling
    Input:
        seismoinfo: seismo information from subfunction 'locate_snap' output
        varnm: variable name to retrieve, 'Vx','Vy','Vz','Txx','Txy','Txz','Tyy','Tyz','Tzz','time'
        outvar: flag string, set 'outdir'
        outvarpath: path of the output result
    Output:
        Velocity or stress values
    Usage:
        Vx  = retrieve_seismo(seismoinfo,'Vx','outdir','./output')
        Tzz = retrieve_seismo(seismoinfo,'Tzz','outdir','./output')
    """

    if os.path.exists(outvarpath):
        fnm_nc=get_fnm_seismo(outvarpath,seismoinfo['n_i'],seismoinfo['n_j'],seismoinfo['n_k'])
        seismonc=Dataset(fnm_nc)
        if varnm == 'time':
            time=np.array(seismonc.variables[varnm][:],dtype=np.float64).flatten()
            return(time)
        else:
            seismo=np.array(seismonc.variables[varnm][:,seismoinfo['npt']],dtype=np.float64).flatten()
            return(seismo)
    else:
        print("Error in 'retrieve_seismo': Directory " + "'" + outvarpath + "'" + \
                " does NOT exist.")



#--------------- retrieve_seismo_sgt ---------------#
def retrieve_seismo_sgt(snapinfo,snapid,M,outvar,outvarpath,mediavar,mediavarpath):

    """
    retrieve_seismo_sgt: Retrieve the displacement with given moment tensor, the strain green tensor and the time
    Input:
        snapinfo: snap information from subfunction 'locate_snap' output
        snapid: snap index, see 'SeisFD3D.conf'
        M: moment tensor
        outvar: flag string, set 'outdir'
        outvarpath: output path
        mediavar: flag string, set 'mediadir'
        mediavarpath: path of the media nc files
    Ouput:
        Displacement, strain and time
    Usage:
        import numpy as np
        M=np.empty((3,3))
        M[0,0]=1; M[1,1]=1; M[2,2]=1;
        M[0,1]=0; M[0,2]=0; M[1,2]=0;
        M[1,0]=M[0,1]; M[2,0]=M[0,2]; M[2,1]=M[1,2]
        U,Exx,Eyy,Ezz,Exy,Exz,Eyz,T = retrieve_seismo_sgt(snapinfo,1,M,'outdir','./output','mediadir','./input')
    """

    pnm_out=outvarpath
    pnm_media=mediavarpath

    rho=gather_media(snapinfo,'rho','mediadir',pnm_media)
    lamd=gather_media(snapinfo,'lambda','mediadir',pnm_media)
    mu=gather_media(snapinfo,'mu','mediadir',pnm_media)

    Txx=retrieve_seismo_snap(snapinfo,snapid,'Txx','outdir',pnm_out)[0]
    Txy=retrieve_seismo_snap(snapinfo,snapid,'Txy','outdir',pnm_out)[0]
    Txz=retrieve_seismo_snap(snapinfo,snapid,'Txz','outdir',pnm_out)[0]
    Tyy=retrieve_seismo_snap(snapinfo,snapid,'Tyy','outdir',pnm_out)[0]
    Tyz=retrieve_seismo_snap(snapinfo,snapid,'Tyz','outdir',pnm_out)[0]
    Tzz,t=retrieve_seismo_snap(snapinfo,snapid,'Tzz','outdir',pnm_out)

    Exx=np.zeros(Txx.shape); Exy=np.zeros(Txy.shape); Exz=np.zeros(Txz.shape)
    Eyy=np.zeros(Tyy.shape); Eyz=np.zeros(Tyz.shape); Ezz=np.zeros(Tzz.shape)

    E1=(lamd+mu)/(mu*(3*lamd+2*mu))
    E2=-lamd/(2*mu*(3*lamd+2*mu))
    E3=1/mu

    nx=Tzz.shape[0]
    ny=Tzz.shape[1]
    nz=Tzz.shape[2]
    nt=Tzz.shape[3]

    for k in range(nz):
        for j in range(ny):
            for i in range(nx):
                Exx[i,j,k,:]=Txx[i,j,k,:]*E1[i,j,k]+Tyy[i,j,k,:]*E2[i,j,k]+Tzz[i,j,k,:]*E2[i,j,k]
                Eyy[i,j,k,:]=Txx[i,j,k,:]*E2[i,j,k]+Tyy[i,j,k,:]*E1[i,j,k]+Tzz[i,j,k,:]*E2[i,j,k]
                Ezz[i,j,k,:]=Txx[i,j,k,:]*E2[i,j,k]+Tyy[i,j,k,:]*E2[i,j,k]+Tzz[i,j,k,:]*E1[i,j,k]
                Exy[i,j,k,:]=Txy[i,j,k,:]*E3[i,j,k]*0.5
                Exz[i,j,k,:]=Txz[i,j,k,:]*E3[i,j,k]*0.5
                Eyz[i,j,k,:]=Tyz[i,j,k,:]*E3[i,j,k]*0.5

    U = Exx*M[0,0] + Eyy*M[1,1] + Ezz*M[2,2] + \
        Exy*(M[0,1] + M[1,0]) + \
        Exz*(M[0,2] + M[2,0]) + \
        Eyz*(M[1,2] + M[2,1])

    return(U,Exx,Eyy,Ezz,Exy,Exz,Eyz,t)



#--------------- retrieve_seismo_sgtonly ---------------#
def retrieve_seismo_sgtonly(snapinfo,snapid,outvar,outvarpath,mediavar,mediavarpath):

    """
    retrieve_seismo_sgtonly: Retrieve the strain green tensor and the time
    Input:
        snapinfo: snap information from subfunction 'locate_snap' output
        snapid: snap index, see 'SeisFD3D.conf'
        outvar: flag string, set 'outdir'
        outvarpath: output path
        mediavar: flag string, set 'mediadir'
        mediavarpath: path of the media nc files
    Ouput:
        Strain green tensor and time
    Usage:
        Exx,Eyy,Ezz,Exy,Exz,Eyz,T = retrieve_seismo_sgtonly(snapinfo,1,'outdir','./output','mediadir','./input')
    """

    pnm_out=outvarpath
    pnm_media=mediavarpath

    rho=gather_media(snapinfo,'rho','mediadir',pnm_media)
    lamd=gather_media(snapinfo,'lambda','mediadir',pnm_media)
    mu=gather_media(snapinfo,'mu','mediadir',pnm_media)

    Txx=retrieve_seismo_snap(snapinfo,snapid,'Txx','outdir',pnm_out)[0]
    Txy=retrieve_seismo_snap(snapinfo,snapid,'Txy','outdir',pnm_out)[0]
    Txz=retrieve_seismo_snap(snapinfo,snapid,'Txz','outdir',pnm_out)[0]
    Tyy=retrieve_seismo_snap(snapinfo,snapid,'Tyy','outdir',pnm_out)[0]
    Tyz=retrieve_seismo_snap(snapinfo,snapid,'Tyz','outdir',pnm_out)[0]
    Tzz,t=retrieve_seismo_snap(snapinfo,snapid,'Tzz','outdir',pnm_out)

    Exx=np.zeros(Txx.shape); Exy=np.zeros(Txy.shape); Exz=np.zeros(Txz.shape)
    Eyy=np.zeros(Tyy.shape); Eyz=np.zeros(Tyz.shape); Ezz=np.zeros(Tzz.shape)

    E1=(lamd+mu)/(mu*(3*lamd+2*mu))
    E2=-lamd/(2*mu*(3*lamd+2*mu))
    E3=1/mu

    nx=Tzz.shape[0]
    ny=Tzz.shape[1]
    nz=Tzz.shape[2]
    nt=Tzz.shape[3]

    for k in range(nz):
        for j in range(ny):
            for i in range(nx):
                Exx[i,j,k,:]=Txx[i,j,k,:]*E1[i,j,k]+Tyy[i,j,k,:]*E2[i,j,k]+Tzz[i,j,k,:]*E2[i,j,k]
                Eyy[i,j,k,:]=Txx[i,j,k,:]*E2[i,j,k]+Tyy[i,j,k,:]*E1[i,j,k]+Tzz[i,j,k,:]*E2[i,j,k]
                Ezz[i,j,k,:]=Txx[i,j,k,:]*E2[i,j,k]+Tyy[i,j,k,:]*E2[i,j,k]+Tzz[i,j,k,:]*E1[i,j,k]
                Exy[i,j,k,:]=Txy[i,j,k,:]*E3[i,j,k]*0.5
                Exz[i,j,k,:]=Txz[i,j,k,:]*E3[i,j,k]*0.5
                Eyz[i,j,k,:]=Tyz[i,j,k,:]*E3[i,j,k]*0.5

    return(Exx,Eyy,Ezz,Exy,Exz,Eyz,t)



#--------------- retrieve_seismo_snap ---------------#
def retrieve_seismo_snap(snapinfo,snapid,varnm,outvar,outvarpath):

    """
    retrieve_seismo_snap: Retrieve velocity and stress of the snap
    Input:
        snapinfo: snap information from subfunction 'locate_snap' output
        snapid: snap index, see 'SeisFD3D.conf'
        varnm: variable to retrieve,'Vx','Vy','Vz','Txx','Txy','Txz','Tyy','Tyz','Tzz'
        outvar: flag string, set 'outdir'
        outvarpath: path of output results
    Output:
        Velocity or stress
    Usage:
        Vx,T = retrieve_seismo_snap(snapinfo,1,'Vx','outdir','./output')
        Tzz  = retrieve_seismo_snap(snapinfo,2,'Tzz','outdir','./output')[0]
    """

    listV=['Vx','Vy','Vz']
    listA=['Ax','Ay','Az']
    listD=['Dx','Dy','Dz']
    listT=['Txx','Txy','Txz','Tyy','Tyz','Tzz']
    if varnm in listV:
        fnm_prefix='vel_'
    elif varnm in listA:
        fnm_prefix='acce_'
    elif varnm in listD:
        fnm_prefix='disp_'
    else:
        fnm_prefix='sgt_'

    pnm_out=outvarpath
    nthd=len(snapinfo)

    if os.path.exists(pnm_out):
        for n in range(nthd):
            n_i=snapinfo[n]['thisid'][0]
            n_j=snapinfo[n]['thisid'][1]
            n_k=snapinfo[n]['thisid'][2]
            
            i1=snapinfo[n]['indxs'][0]
            j1=snapinfo[n]['indxs'][1]
            k1=snapinfo[n]['indxs'][2]

            i2=snapinfo[n]['indxe'][0]
            j2=snapinfo[n]['indxe'][1]
            k2=snapinfo[n]['indxe'][2]

            subs=snapinfo[n]['subs']
            subc=snapinfo[n]['subc']
            subt=snapinfo[n]['subt']

            nofnc=0
            nt=0
            ninnc=snapinfo[n]['ttriple'][0]
            ncount=snapinfo[n]['ttriple'][1]
            nstride=snapinfo[n]['ttriple'][2]

            while True:
                nofnc=nofnc+1
                fnm_snap=get_fnm_snap(pnm_out,fnm_prefix,n_i,n_j,n_k,snapid,nofnc)
                if os.path.exists(fnm_snap):
                    subs=subs[::-1]
                    subc=subc[::-1]
                    subt=subt[::-1]

                    snapnc=Dataset(fnm_snap)
                    tdim={}
                    tdim['Name']=snapnc.dimensions['time'].name
                    tdim['Length']=snapnc.dimensions['time'].size

                    if tdim['Length'] == 0:
                        break

                    LenT=tdim['Length']
                    ntinc=int(np.floor((LenT-ninnc)/nstride)+1)

                    if ncount != -1 and ntinc_nt >= ncount:
                        ntinc=ncount-nt

                    tblk=np.array(snapnc.variables['time'][ninnc-1:ninnc+ntinc*nstride-1:nstride])
                    if nt == 0:
                        t=tblk
                    else:
                        t=np.append(t,tblk,axis=0)


                    vblk=np.array(snapnc.variables[varnm][\
                            ninnc-1:ninnc+ntinc*nstride-1:nstride,\
                            subs[0]-1:subs[0]+subc[0]*subt[0]-1:subt[0],\
                            subs[1]-1:subs[1]+subc[1]*subt[1]-1:subt[1],\
                            subs[2]-1:subs[2]+subc[2]*subt[2]-1:subt[2]],\
                            dtype=np.float64)

                    if n == 0 and nt == 0:
                        vold=vblk

                    vnew=np.empty((max(nt+ntinc,vold.shape[0]),max(k2,vold.shape[1]),\
                            max(j2,vold.shape[2]),max(i2,vold.shape[3])))

                    vnew[:vold.shape[0],:vold.shape[1],:vold.shape[2],:vold.shape[3]]=vold

                    vnew[nt:nt+ntinc,k1-1:k2,j1-1:j2,i1-1:i2]=vblk

                    vold=vnew

                    nt=nt+ntinc
                    ninnc=nstride-(LenT-(ninnc+(ntinc-1)*nstride))

                    if ncount != -1 and nt >= ncount:
                        break

                else:
#                    print("Error in 'retrieve_seismo_snap': File " + "'" + fnm_snap + "'" + \
#                            " does NOT exist.")
                    break

        vnew=vnew.transpose(3,2,1,0)

        return(vnew,t)

    else:
        print("Error in 'retrieve_seismo_snap': Directory " + "'" + pnm_out + "'" + \
                " does NOT exist.")



#--------------- retrieve_station ---------------#
def retrieve_station(seismoinfo,varnm,stavar,stavarpath):

    """
    retrieve_station: Retrieve the grid/coordinates of seismo
    Input:
        seismoinfo: seismo information from subfunction 'locate_seismo' output
        varnm: variable name, 'grid','indx','gindx','coord','id'
        stavar: flag string, set 'stationdir'
        stavarpath: path of station nc files
    Output:
        Grid/coordinate/index values
    Usage:
        coord_grid = retrieve_station(seismoinfo,'grid','stationdir','./input')
    """

    if os.path.exists(stavarpath):
        fnm_nc=get_fnm_station(stavarpath,seismoinfo['n_i'],seismoinfo['n_j'],seismoinfo['n_k'])
        stanc=Dataset(fnm_nc)
        stagrid=np.array(stanc.variables[varnm][seismoinfo['npt'],:],dtype=np.float64).flatten()
        return(stagrid)
    else:
        print("Error in 'retrieve_station': Directory " + "'" + stavarpath + "'" + \
                " does NOT exist.")
